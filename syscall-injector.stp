%{
#include <asm-generic/errno-base.h>
%}

function get_errno:long () %{
	STAP_RETVALUE = -EPERM;
%}

global pids
global blocked_files
global syscall


probe begin {
	print ("Probing\n")
}


probe procfs("blocked_files").read {
	foreach (file in blocked_files) {
		$value .= sprintf ("%s\n", file)
	}
}

probe procfs("blocked_files").write {
	str = substr ($value, 0, strlen ($value))
	if ( str == "%flush%\n" ) {
		delete blocked_files
		next
	}
	blocked_files [$value] = 1
}

probe procfs("syscall").read {
	$value = syscall
}

probe procfs("syscall").write {
	syscall = $value
}

probe procfs("pids").read {
	foreach (pid in pids) {
		$value = sprintf ("%d\n", pid)
	}
}

probe procfs("pids").write {
	pid = strtol (tokenize ($value, "\n,"), 10)

	if ( pid == 0 ) {
		delete pids
		next
	}
	pids [ pid ] = 1
}

probe kprocess.create {
	if ( pid() in pids ) {
		pids [new_pid] = 1
	}
}

probe kprocess.release {
	delete pids [released_pid]
}

function do_work:long (name, path) {

	if ( name != syscall ) {
		return 0;
	}

	tpath = user_string (path)

	if ( !(pid() in pids) ) {
		return 0
	}

	if ( tpath in blocked_files ) {
		return get_errno ()
	}
}


probe syscall.open.return {
	ret = do_work (name, $filename)
	if ( ret == 0 ) { next }
	$return = ret
}

probe syscall.unlink.return {
	ret = do_work (name, $pathname)
	if ( ret == 0 ) { next }
	$return = ret
}

probe syscall.creat.return {
	ret = do_work (name, $pathname)
	if ( ret == 0 ) { next }
	$return = ret
}

probe syscall.access.return {
	ret = do_work (name, $filename)
	if ( ret == 0 ) { next }
	$return = ret
}

probe syscall.stat.return {
	ret = do_work (name, $filename)
	if ( ret == 0 ) { next }
	$return = ret
}

probe syscall.lstat.return {
	ret = do_work (name, $filename)
	if ( ret == 0 ) { next }
	$return = ret
}

probe syscall.statfs.return {
	ret = do_work (name, $pathname)
	if ( ret == 0 ) { next }
	$return = ret
}

probe syscall.unlink.return {
	ret = do_work (name, $pathname)
	if ( ret == 0 ) { next }
	$return = ret
}
